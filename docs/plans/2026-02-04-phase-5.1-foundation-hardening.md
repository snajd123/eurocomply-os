# Phase 5.1: Foundation Hardening + Handler Rename — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Harden the evaluator, MCP server, and boot sequence so that all downstream phases (5.2–5.7) build on a robust foundation. Rename the one domain-specific handler to its generic name.

**Architecture:** The evaluator (`packages/kernel-vm/src/evaluator.ts`) gets try/catch error containment and a configurable timeout. The MCP server (`packages/platform-services/src/mcp/server.ts` + `tools.ts`) gets Zod input validation on all 16 existing tools, proper HTTP status codes (400/401/403/404/409/500), and full JSON Schema tool descriptions in `GET /mcp/tools`. The boot sequence (`apps/spoke-runtime/src/boot.ts`) gets fail-fast behavior on required pack load failure. The handler rename (`core:bom_sum` → `core:collection_sum`) touches the handler file, registry, and all tests.

**Tech Stack:** TypeScript, Vitest, Zod, Hono, `@eurocomply/kernel-vm`, `@eurocomply/platform-services`, `@eurocomply/types`

### Known Limitations (document, do not solve)

1. **Timeout cannot kill CPU-bound handlers.** Node.js is single-threaded and the kernel-vm is synchronous. The timeout check runs _between_ handler invocations (before/after `evalNode`). A single handler that enters `while(true)` will block the event loop and never hit the timeout check. This is acceptable for Phase 5.1 — handlers are authored code, not user input. If a handler hangs, it's a handler bug. A future mitigation (worker threads, WASM sandbox) can be added in Phase 5.7 hardening if real-world usage warrants it. **The plan must document this in a code comment where the timeout is implemented.**

2. **AST config children are not recursively validated by Zod.** `ASTNodeSchema` validates `config` as `z.record(z.string(), z.unknown())`. Nested AST children inside `config.conditions`, `config.steps`, and `config.then` are `z.unknown()` — they pass schema validation even if malformed. This is acceptable because the kernel-vm evaluator validates handler existence at runtime and returns structured errors (Task 2). Deep recursive Zod validation of AST configs would require per-handler config schemas, which belongs in Phase 5.2 (handler implementation). **Do not try to make `EvaluateInputSchema` recursively validate nested AST nodes.**

3. **eurocomply-registry CLAUDE.md must be updated after Task 1.** The rename from `core:bom_sum` → `core:collection_sum` has zero impact on existing packs (no pack references `core:bom_sum`), but the registry repo's CLAUDE.md must list the correct 52-handler inventory so pack authors know the available primitives. **This is a manual step outside this plan — the project owner will handle it.**

---

## Task 1: Rename `core:bom_sum` to `core:collection_sum`

**Files:**
- Rename: `packages/kernel-vm/src/handlers/computation/bom-sum.ts` → `packages/kernel-vm/src/handlers/computation/collection-sum.ts`
- Modify: `packages/kernel-vm/src/handlers/index.ts:12,21`
- Modify: `packages/kernel-vm/src/handlers/computation/computation.test.ts:2,23-32`
- Modify: `packages/kernel-vm/src/evaluator.test.ts:40`
- Modify: `packages/kernel-vm/src/index.ts` (no changes needed — exports `createDefaultRegistry`, not individual handlers)

**Step 1: Write the failing test**

Update `packages/kernel-vm/src/handlers/computation/computation.test.ts` — change the import and `describe` block to reference the new name. The test should fail because the file `collection-sum.ts` doesn't exist yet.

```typescript
// In computation.test.ts, line 2:
// BEFORE:
import { bomSumHandler } from './bom-sum.js';
// AFTER:
import { collectionSumHandler } from './collection-sum.js';

// Line 23-32: Change test block
describe('core:collection_sum', () => {
  it('sums a field across all items', () => {
    const r = collectionSumHandler.execute({ source: { field: 'materials' }, field: 'lead_ppm' }, null, ctx, noopEvaluate);
    expect(r.success).toBe(true);
    expect((r.value as any).sum).toBe(35);
  });
  it('applies filter', () => {
    const r = collectionSumHandler.execute({ source: { field: 'materials' }, field: 'lead_ppm', filter: { field: 'type', equals: 'active' } }, null, ctx, noopEvaluate);
    expect((r.value as any).sum).toBe(15);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run src/handlers/computation/computation.test.ts`
Expected: FAIL — cannot resolve `./collection-sum.js`

**Step 3: Create the renamed handler file**

Copy `packages/kernel-vm/src/handlers/computation/bom-sum.ts` to `packages/kernel-vm/src/handlers/computation/collection-sum.ts` and update the internals:

```typescript
// packages/kernel-vm/src/handlers/computation/collection-sum.ts
import type { HandlerDefinition } from '../../handler.js';
import { resolveValue, getNestedValue } from '../../resolve.js';
import { makeSuccess, makeFailure, now } from '../../result.js';

const ID = 'core:collection_sum';
const VERSION = '1.0.0';

export const collectionSumHandler: HandlerDefinition = {
  id: ID,
  version: VERSION,
  category: 'computation',
  description: 'Sum a numeric field across items in a collection',

  execute(config, input, context, _evaluate) {
    const start = now();
    const cfg = config as {
      source: unknown;
      field: string;
      filter?: { field: string; equals: unknown };
    };

    const source = resolveValue(cfg.source, context, input);
    if (!Array.isArray(source)) {
      return makeFailure(
        { sum: 0 },
        {
          summary: 'source is not array',
          handler_id: ID,
          handler_version: VERSION,
          input: cfg,
          execution_path: ID,
          duration_ms: now() - start,
          error: { message: 'not array' },
        },
      );
    }

    let items = source;
    if (cfg.filter) {
      items = items.filter(
        (item) => getNestedValue(item, cfg.filter!.field) === cfg.filter!.equals,
      );
    }

    const sum = items.reduce(
      (a, item) => a + (Number(getNestedValue(item, cfg.field)) || 0),
      0,
    );

    return makeSuccess(
      { sum, items_counted: items.length },
      {
        summary: `Sum '${cfg.field}': ${sum} (${items.length} items)`,
        handler_id: ID,
        handler_version: VERSION,
        input: cfg,
        execution_path: ID,
        duration_ms: now() - start,
      },
    );
  },
};
```

**Step 4: Update the handler registry index**

Modify `packages/kernel-vm/src/handlers/index.ts`:

```typescript
// BEFORE (line 12):
import { bomSumHandler } from './computation/bom-sum.js';

// AFTER:
import { collectionSumHandler } from './computation/collection-sum.js';

// BEFORE (line 21, in the array):
bomSumHandler,

// AFTER:
collectionSumHandler,
```

**Step 5: Update the evaluator test**

Modify `packages/kernel-vm/src/evaluator.test.ts` line 40:

```typescript
// BEFORE:
{ handler: 'core:bom_sum', config: { source: { field: 'materials' }, field: 'lead_ppm' } },

// AFTER:
{ handler: 'core:collection_sum', config: { source: { field: 'materials' }, field: 'lead_ppm' } },
```

Also update the test description on line 38:

```typescript
// BEFORE:
it('evaluates pipe: bom_sum → threshold', () => {

// AFTER:
it('evaluates pipe: collection_sum → threshold', () => {
```

**Step 6: Delete the old handler file**

Delete: `packages/kernel-vm/src/handlers/computation/bom-sum.ts`

**Step 7: Run all tests to verify the rename works**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run`
Expected: ALL PASS — both computation.test.ts and evaluator.test.ts

**Step 8: Commit**

```bash
git add packages/kernel-vm/src/handlers/computation/collection-sum.ts \
       packages/kernel-vm/src/handlers/computation/computation.test.ts \
       packages/kernel-vm/src/handlers/index.ts \
       packages/kernel-vm/src/evaluator.test.ts
git rm packages/kernel-vm/src/handlers/computation/bom-sum.ts
git commit -m "refactor(kernel-vm): rename core:bom_sum to core:collection_sum

Generic handler names — domain semantics belong in packs, not handler IDs."
```

---

## Task 2: Evaluator error containment (try/catch)

**Files:**
- Modify: `packages/kernel-vm/src/evaluator.ts:9-18`
- Modify: `packages/kernel-vm/src/evaluator.test.ts` (add new test cases)

**Step 1: Write the failing tests**

Add these tests to `packages/kernel-vm/src/evaluator.test.ts`:

```typescript
it('returns structured error when handler throws', () => {
  // Create a registry with a handler that throws
  const { HandlerRegistry } = await import('./registry.js');
  const badRegistry = new HandlerRegistry();
  badRegistry.register({
    id: 'core:exploder',
    version: '1.0.0',
    category: 'computation',
    description: 'Always throws',
    execute() { throw new Error('kaboom'); },
  });

  const ast: ASTNode = { handler: 'core:exploder', config: {} };
  const r = evaluate(ast, ctx, badRegistry);
  expect(r.success).toBe(false);
  expect(r.trace.status).toBe('error');
  expect(r.trace.error?.message).toBe('kaboom');
  expect(r.explanation.summary).toContain('kaboom');
});

it('returns structured error for unknown handler instead of throwing', () => {
  const ast: ASTNode = { handler: 'core:nonexistent', config: {} };
  const r = evaluate(ast, ctx, createDefaultRegistry());
  expect(r.success).toBe(false);
  expect(r.trace.status).toBe('error');
  expect(r.trace.error?.message).toContain('Unknown handler');
});
```

Also update the existing "throws on unknown handler" test — it currently expects a throw. That test should be removed or updated to match the new behavior (returns structured error instead of throwing).

Remove this existing test (line 47-49):
```typescript
// DELETE this test:
it('throws on unknown handler', () => {
  expect(() => evaluate({ handler: 'core:nope', config: {} }, ctx, createDefaultRegistry())).toThrow('Unknown handler');
});
```

**Step 2: Run tests to verify failures**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run src/evaluator.test.ts`
Expected: FAIL — the new tests fail because `evaluate()` still throws, and the deleted test is gone.

**Step 3: Implement error containment in the evaluator**

Modify `packages/kernel-vm/src/evaluator.ts`:

```typescript
import type { ASTNode, ExecutionContext, HandlerResult } from '@eurocomply/types';
import type { HandlerRegistry } from './registry.js';
import type { EvaluateFn } from './handler.js';
import { makeFailure, now } from './result.js';

export function evaluate(ast: ASTNode, context: ExecutionContext, registry: HandlerRegistry): HandlerResult {
  return evalNode(ast, context, context.entity_data, registry, 'root');
}

function evalNode(node: ASTNode, context: ExecutionContext, input: unknown, registry: HandlerRegistry, path: string): HandlerResult {
  const start = now();
  const handler = registry.get(node.handler);
  if (!handler) {
    return makeFailure(null, {
      summary: `Unknown handler: ${node.handler}`,
      handler_id: node.handler,
      handler_version: '0.0.0',
      input: node.config,
      execution_path: path,
      duration_ms: now() - start,
      error: { message: `Unknown handler: ${node.handler}` },
    });
  }

  try {
    const evaluateFn: EvaluateFn = (child, ctx, childInput) =>
      evalNode(child, ctx, childInput ?? input, registry, `${path} > ${child.handler}`);

    const result = handler.execute(node.config, input, context, evaluateFn);
    return { ...result, trace: { ...result.trace, execution_path: path } };
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    return makeFailure(null, {
      summary: `Handler ${node.handler} threw: ${message}`,
      handler_id: node.handler,
      handler_version: handler.version,
      input: node.config,
      execution_path: path,
      duration_ms: now() - start,
      error: { message },
    });
  }
}
```

**Step 4: Run tests to verify they pass**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run src/evaluator.test.ts`
Expected: ALL PASS

**Step 5: Run the full kernel-vm test suite**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run`
Expected: ALL PASS — verify the handler rename + evaluator error changes work together

**Step 6: Commit**

```bash
git add packages/kernel-vm/src/evaluator.ts packages/kernel-vm/src/evaluator.test.ts
git commit -m "feat(kernel-vm): evaluator returns structured errors instead of throwing

Wraps handler execution in try/catch. Unknown handlers and handler
exceptions return HandlerResult with success=false and trace.status='error'
instead of propagating exceptions to the caller."
```

---

## Task 3: Evaluator timeout enforcement

**Files:**
- Modify: `packages/kernel-vm/src/evaluator.ts`
- Modify: `packages/kernel-vm/src/evaluator.test.ts` (add timeout test)

**Step 1: Write the failing test**

Add to `packages/kernel-vm/src/evaluator.test.ts`:

```typescript
it('returns timeout error when evaluation exceeds time limit', () => {
  const { HandlerRegistry } = await import('./registry.js');
  const slowRegistry = new HandlerRegistry();
  slowRegistry.register({
    id: 'core:slow',
    version: '1.0.0',
    category: 'computation',
    description: 'Simulates a long-running handler',
    execute() {
      // Busy-wait for 100ms (well over our 10ms test timeout)
      const end = Date.now() + 100;
      while (Date.now() < end) { /* spin */ }
      return { success: true, value: 'done', explanation: { summary: 'done', steps: [] }, trace: { handler_id: 'core:slow', handler_version: '1.0.0', duration_ms: 100, input: {}, output: 'done', execution_path: 'root', status: 'success' as const } };
    },
  });

  const ast: ASTNode = { handler: 'core:slow', config: {} };
  const r = evaluate(ast, ctx, slowRegistry, { timeout_ms: 10 });
  expect(r.success).toBe(false);
  expect(r.trace.status).toBe('error');
  expect(r.trace.error?.message).toContain('timeout');
});

it('succeeds when evaluation completes within time limit', () => {
  const ast: ASTNode = { handler: 'core:threshold_check', config: { value: { field: 'lead_concentration' }, operator: 'lt', threshold: 0.001 } };
  const r = evaluate(ast, ctx, createDefaultRegistry(), { timeout_ms: 5000 });
  expect(r.success).toBe(true);
});
```

**Step 2: Run tests to verify they fail**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run src/evaluator.test.ts`
Expected: FAIL — `evaluate()` doesn't accept an options parameter yet

**Step 3: Implement timeout enforcement**

The kernel-vm is synchronous — we cannot use `setTimeout`. Instead, we track a deadline and check it between handler invocations (i.e., before each child evaluation in `evalNode`). Individual handlers are atomic — we can only timeout between handler calls.

Modify `packages/kernel-vm/src/evaluator.ts`:

```typescript
import type { ASTNode, ExecutionContext, HandlerResult } from '@eurocomply/types';
import type { HandlerRegistry } from './registry.js';
import type { EvaluateFn } from './handler.js';
import { makeFailure, now } from './result.js';

export interface EvaluateOptions {
  /**
   * Maximum wall-clock milliseconds for the entire evaluation. Default: no limit.
   *
   * LIMITATION: Timeout is checked between handler invocations, not during them.
   * A single handler that blocks the thread (infinite loop, CPU-bound work) will
   * not be interrupted — Node.js is single-threaded and the kernel-vm is synchronous.
   * The timeout catches runaway compositions (deeply nested ASTs, large for_each),
   * not individual handler hangs.
   */
  timeout_ms?: number;
}

export function evaluate(
  ast: ASTNode,
  context: ExecutionContext,
  registry: HandlerRegistry,
  options?: EvaluateOptions,
): HandlerResult {
  const deadline = options?.timeout_ms != null ? now() + options.timeout_ms : undefined;
  return evalNode(ast, context, context.entity_data, registry, 'root', deadline);
}

function evalNode(
  node: ASTNode,
  context: ExecutionContext,
  input: unknown,
  registry: HandlerRegistry,
  path: string,
  deadline?: number,
): HandlerResult {
  const start = now();

  // Check timeout before executing this node
  if (deadline != null && now() > deadline) {
    return makeFailure(null, {
      summary: `Evaluation timeout exceeded at ${node.handler}`,
      handler_id: node.handler,
      handler_version: '0.0.0',
      input: node.config,
      execution_path: path,
      duration_ms: now() - start,
      error: { message: `Evaluation timeout exceeded at handler ${node.handler}` },
    });
  }

  const handler = registry.get(node.handler);
  if (!handler) {
    return makeFailure(null, {
      summary: `Unknown handler: ${node.handler}`,
      handler_id: node.handler,
      handler_version: '0.0.0',
      input: node.config,
      execution_path: path,
      duration_ms: now() - start,
      error: { message: `Unknown handler: ${node.handler}` },
    });
  }

  try {
    const evaluateFn: EvaluateFn = (child, ctx, childInput) =>
      evalNode(child, ctx, childInput ?? input, registry, `${path} > ${child.handler}`, deadline);

    const result = handler.execute(node.config, input, context, evaluateFn);

    // Check timeout after handler execution (catches single long-running handlers)
    if (deadline != null && now() > deadline) {
      return makeFailure(null, {
        summary: `Evaluation timeout exceeded after ${node.handler}`,
        handler_id: node.handler,
        handler_version: handler.version,
        input: node.config,
        execution_path: path,
        duration_ms: now() - start,
        error: { message: `Evaluation timeout exceeded after handler ${node.handler}` },
      });
    }

    return { ...result, trace: { ...result.trace, execution_path: path } };
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    return makeFailure(null, {
      summary: `Handler ${node.handler} threw: ${message}`,
      handler_id: node.handler,
      handler_version: handler.version,
      input: node.config,
      execution_path: path,
      duration_ms: now() - start,
      error: { message },
    });
  }
}
```

**Step 4: Export the new type from the package index**

Modify `packages/kernel-vm/src/index.ts` — add `EvaluateOptions` to exports:

```typescript
// Add to the existing export line:
export { evaluate, type EvaluateOptions } from './evaluator.js';
```

**Step 5: Run tests to verify they pass**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run src/evaluator.test.ts`
Expected: ALL PASS

**Step 6: Update the ExecutionLoop to pass timeout**

Modify `packages/platform-services/src/execution-loop.ts` line 158. The `evaluate()` call should pass an options object with a configurable default timeout.

Add a `timeout_ms` option to the `ExecutionLoop` constructor and use it:

```typescript
// In ExecutionLoop constructor, add a timeoutMs parameter:
export class ExecutionLoop {
  constructor(
    private db: PostgresConnectionManager,
    private entityService: EntityService,
    private audit: AuditLogger,
    private registry: HandlerRegistry,
    private relationService?: RelationService,
    private aiBridge?: AIBridge,
    private evaluationTimeoutMs: number = 5000,
  ) {}

  // ... in evaluate() method, line 158:
  // BEFORE:
  const handlerResult = evaluate(input.rule, executionContext, this.registry);
  // AFTER:
  const handlerResult = evaluate(input.rule, executionContext, this.registry, {
    timeout_ms: this.evaluationTimeoutMs,
  });
```

Also update the import at the top of `execution-loop.ts`:

```typescript
// BEFORE:
import { evaluate, isDataReference } from '@eurocomply/kernel-vm';
// AFTER:
import { evaluate, isDataReference, type EvaluateOptions } from '@eurocomply/kernel-vm';
```

**Step 7: Run full test suite**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/kernel-vm test -- --run && pnpm --filter @eurocomply/platform-services test -- --run`
Expected: ALL PASS — both packages

**Step 8: Commit**

```bash
git add packages/kernel-vm/src/evaluator.ts \
       packages/kernel-vm/src/evaluator.test.ts \
       packages/kernel-vm/src/index.ts \
       packages/platform-services/src/execution-loop.ts
git commit -m "feat(kernel-vm): add configurable timeout to evaluator

Checks wall-clock time before and after each handler invocation.
Default 5s in ExecutionLoop. Returns structured HandlerResult with
trace.status='error' on timeout.

Limitation: timeout is inter-handler only. A single CPU-bound handler
that blocks the thread will not be interrupted (Node.js single-threaded,
kernel-vm synchronous). Catches runaway AST compositions, not individual
handler hangs."
```

---

## Task 4: Define Zod input schemas for all 16 existing MCP tools

**Files:**
- Create: `packages/platform-services/src/mcp/schemas.ts`
- Modify: `packages/platform-services/src/mcp/tools.ts:29-138`
- Create: `packages/platform-services/src/mcp/schemas.test.ts`

**Step 1: Write the failing test**

Create `packages/platform-services/src/mcp/schemas.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import {
  EntityDefineInputSchema,
  EntityCreateInputSchema,
  EntityGetInputSchema,
  EntityUpdateInputSchema,
  EntityListInputSchema,
  FileUploadInputSchema,
  FileGetInputSchema,
  JobSubmitInputSchema,
  JobStatusInputSchema,
  AuditQueryInputSchema,
  EvaluateInputSchema,
  RegistryInstallInputSchema,
  RegistryListInputSchema,
  RegistryLockInputSchema,
  RegistryLocksInputSchema,
  RegistrySaveLockInputSchema,
} from './schemas.js';

describe('MCP tool input schemas', () => {
  describe('entity:define', () => {
    it('accepts valid input', () => {
      const result = EntityDefineInputSchema.safeParse({
        entity_type: 'product',
        schema: { name: { type: 'string' } },
      });
      expect(result.success).toBe(true);
    });

    it('rejects missing entity_type', () => {
      const result = EntityDefineInputSchema.safeParse({
        schema: { name: { type: 'string' } },
      });
      expect(result.success).toBe(false);
    });
  });

  describe('entity:create', () => {
    it('accepts valid input', () => {
      const result = EntityCreateInputSchema.safeParse({
        entity_type: 'product',
        data: { name: 'Widget' },
      });
      expect(result.success).toBe(true);
    });

    it('rejects missing data', () => {
      const result = EntityCreateInputSchema.safeParse({
        entity_type: 'product',
      });
      expect(result.success).toBe(false);
    });
  });

  describe('entity:get', () => {
    it('accepts valid input', () => {
      const result = EntityGetInputSchema.safeParse({
        entity_type: 'product',
        entity_id: 'p-123',
      });
      expect(result.success).toBe(true);
    });

    it('rejects missing entity_id', () => {
      const result = EntityGetInputSchema.safeParse({
        entity_type: 'product',
      });
      expect(result.success).toBe(false);
    });
  });

  describe('entity:update', () => {
    it('accepts valid input', () => {
      const result = EntityUpdateInputSchema.safeParse({
        entity_type: 'product',
        entity_id: 'p-123',
        data: { name: 'Updated Widget' },
      });
      expect(result.success).toBe(true);
    });
  });

  describe('entity:list', () => {
    it('accepts valid input', () => {
      const result = EntityListInputSchema.safeParse({
        entity_type: 'product',
      });
      expect(result.success).toBe(true);
    });

    it('accepts optional limit/offset', () => {
      const result = EntityListInputSchema.safeParse({
        entity_type: 'product',
        limit: 10,
        offset: 0,
      });
      expect(result.success).toBe(true);
    });
  });

  describe('file:upload', () => {
    it('accepts valid input', () => {
      const result = FileUploadInputSchema.safeParse({
        filename: 'test.pdf',
        content_type: 'application/pdf',
        content: 'base64data',
      });
      expect(result.success).toBe(true);
    });

    it('rejects missing filename', () => {
      const result = FileUploadInputSchema.safeParse({
        content_type: 'application/pdf',
        content: 'base64data',
      });
      expect(result.success).toBe(false);
    });
  });

  describe('file:get', () => {
    it('accepts valid input', () => {
      const result = FileGetInputSchema.safeParse({ file_id: 'f-123' });
      expect(result.success).toBe(true);
    });
  });

  describe('job:submit', () => {
    it('accepts valid input', () => {
      const result = JobSubmitInputSchema.safeParse({
        job_type: 'evaluation',
        payload: { entity_id: 'p-1' },
      });
      expect(result.success).toBe(true);
    });
  });

  describe('job:status', () => {
    it('accepts valid input', () => {
      const result = JobStatusInputSchema.safeParse({ job_id: 'j-123' });
      expect(result.success).toBe(true);
    });
  });

  describe('audit:query', () => {
    it('accepts valid input', () => {
      const result = AuditQueryInputSchema.safeParse({});
      expect(result.success).toBe(true);
    });

    it('accepts optional filters', () => {
      const result = AuditQueryInputSchema.safeParse({
        action: 'evaluate',
        resource_entity_id: 'p-1',
      });
      expect(result.success).toBe(true);
    });
  });

  describe('evaluate', () => {
    it('accepts valid input', () => {
      const result = EvaluateInputSchema.safeParse({
        entity_type: 'product',
        entity_id: 'p-1',
        rule: { handler: 'core:threshold_check', config: { value: 10, operator: 'lt', threshold: 100 } },
        compliance_lock_id: 'lock-1',
        vertical_id: 'cosmetics',
        market: 'EU',
      });
      expect(result.success).toBe(true);
    });

    it('rejects missing rule', () => {
      const result = EvaluateInputSchema.safeParse({
        entity_type: 'product',
        entity_id: 'p-1',
        compliance_lock_id: 'lock-1',
        vertical_id: 'cosmetics',
        market: 'EU',
      });
      expect(result.success).toBe(false);
    });
  });

  describe('registry:install', () => {
    it('accepts valid pack manifest', () => {
      const result = RegistryInstallInputSchema.safeParse({
        name: 'eu-clp',
        version: '1.0.0',
        type: 'logic',
      });
      expect(result.success).toBe(true);
    });
  });

  describe('registry:lock', () => {
    it('accepts lock_id', () => {
      const result = RegistryLockInputSchema.safeParse({ lock_id: 'lock-1' });
      expect(result.success).toBe(true);
    });
  });

  describe('registry:save-lock', () => {
    it('accepts lock object', () => {
      const result = RegistrySaveLockInputSchema.safeParse({
        lock_id: 'lock-1',
        packs: [],
        handler_vm_version: '1.0.0',
        created_at: '2026-01-01T00:00:00Z',
      });
      expect(result.success).toBe(true);
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/platform-services test -- --run src/mcp/schemas.test.ts`
Expected: FAIL — `./schemas.js` module doesn't exist

**Step 3: Create the Zod schema definitions**

Create `packages/platform-services/src/mcp/schemas.ts`:

```typescript
import { z } from 'zod';
import { ASTNodeSchema } from '@eurocomply/types';

// --- Entity Tools ---

export const EntityDefineInputSchema = z.object({
  entity_type: z.string().min(1),
  schema: z.record(z.string(), z.unknown()),
});

export const EntityCreateInputSchema = z.object({
  entity_type: z.string().min(1),
  data: z.record(z.string(), z.unknown()),
});

export const EntityGetInputSchema = z.object({
  entity_type: z.string().min(1),
  entity_id: z.string().min(1),
});

export const EntityUpdateInputSchema = z.object({
  entity_type: z.string().min(1),
  entity_id: z.string().min(1),
  data: z.record(z.string(), z.unknown()),
});

export const EntityListInputSchema = z.object({
  entity_type: z.string().min(1),
  limit: z.number().int().positive().optional(),
  offset: z.number().int().nonnegative().optional(),
  filter: z.record(z.string(), z.unknown()).optional(),
});

// --- File Tools ---

export const FileUploadInputSchema = z.object({
  filename: z.string().min(1),
  content_type: z.string().min(1),
  content: z.string().min(1), // base64-encoded
  entity_type: z.string().optional(),
  entity_id: z.string().optional(),
});

export const FileGetInputSchema = z.object({
  file_id: z.string().min(1),
});

// --- Job Tools ---

export const JobSubmitInputSchema = z.object({
  job_type: z.string().min(1),
  payload: z.record(z.string(), z.unknown()),
  priority: z.number().int().optional(),
});

export const JobStatusInputSchema = z.object({
  job_id: z.string().min(1),
});

// --- Audit Tools ---

export const AuditQueryInputSchema = z.object({
  action: z.string().optional(),
  resource_entity_type: z.string().optional(),
  resource_entity_id: z.string().optional(),
  actor_id: z.string().optional(),
  from: z.string().optional(),
  to: z.string().optional(),
  limit: z.number().int().positive().optional(),
  offset: z.number().int().nonnegative().optional(),
});

// --- Evaluate Tool ---

// NOTE: ASTNodeSchema validates the top-level node (handler: string, config: record)
// but does NOT recursively validate nested children inside config.conditions,
// config.steps, or config.then — those are z.unknown(). This is intentional:
// the evaluator validates handler existence at runtime and returns structured errors.
// Deep config validation requires per-handler schemas (Phase 5.2 scope).
export const EvaluateInputSchema = z.object({
  entity_type: z.string().min(1),
  entity_id: z.string().min(1),
  rule: ASTNodeSchema,
  compliance_lock_id: z.string().min(1),
  vertical_id: z.string().min(1),
  market: z.string().min(1),
  data: z.record(z.string(), z.unknown()).optional(),
});

// --- Registry Tools ---

export const RegistryInstallInputSchema = z.object({
  name: z.string().min(1),
  version: z.string().min(1),
  type: z.string().min(1),
}).passthrough(); // Allow additional pack manifest fields

export const RegistryListInputSchema = z.object({}).optional();

export const RegistryLockInputSchema = z.object({
  lock_id: z.string().min(1),
});

export const RegistryLocksInputSchema = z.object({}).optional();

export const RegistrySaveLockInputSchema = z.object({
  lock_id: z.string().min(1),
  packs: z.array(z.unknown()),
  handler_vm_version: z.string().min(1),
  created_at: z.string(),
}).passthrough();

// --- Schema Map (tool name → Zod schema) ---

export const toolInputSchemas: Record<string, z.ZodTypeAny> = {
  'entity:define': EntityDefineInputSchema,
  'entity:create': EntityCreateInputSchema,
  'entity:get': EntityGetInputSchema,
  'entity:update': EntityUpdateInputSchema,
  'entity:list': EntityListInputSchema,
  'file:upload': FileUploadInputSchema,
  'file:get': FileGetInputSchema,
  'job:submit': JobSubmitInputSchema,
  'job:status': JobStatusInputSchema,
  'audit:query': AuditQueryInputSchema,
  'evaluate': EvaluateInputSchema,
  'registry:install': RegistryInstallInputSchema,
  'registry:list': RegistryListInputSchema ?? z.object({}).optional(),
  'registry:lock': RegistryLockInputSchema,
  'registry:locks': RegistryLocksInputSchema ?? z.object({}).optional(),
  'registry:save-lock': RegistrySaveLockInputSchema,
};
```

**Step 4: Run schema tests to verify they pass**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/platform-services test -- --run src/mcp/schemas.test.ts`
Expected: ALL PASS

**Step 5: Commit**

```bash
git add packages/platform-services/src/mcp/schemas.ts \
       packages/platform-services/src/mcp/schemas.test.ts
git commit -m "feat(platform-services): add Zod input schemas for all 16 MCP tools

Each tool gets a Zod schema defining its required and optional input
fields. Exported as a toolInputSchemas map keyed by tool name."
```

---

## Task 5: Wire Zod validation into MCP tool router

**Files:**
- Modify: `packages/platform-services/src/mcp/tools.ts:126-136`
- Create: `packages/platform-services/src/mcp/validation.test.ts`

**Step 1: Write the failing test**

Create `packages/platform-services/src/mcp/validation.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { boot, type SpokeInstance } from '../../../../apps/spoke-runtime/src/boot.js';
import { PostgreSqlContainer, type StartedPostgreSqlContainer } from '@testcontainers/postgresql';

describe('MCP input validation', () => {
  let container: StartedPostgreSqlContainer;
  let spoke: SpokeInstance;

  beforeAll(async () => {
    container = await new PostgreSqlContainer('postgres:16-alpine').start();
    spoke = await boot({
      port: 0,
      postgres: {
        host: container.getHost(),
        port: container.getMappedPort(5432),
        database: container.getDatabase(),
        user: container.getUsername(),
        password: container.getPassword(),
      },
      tenantId: 'validation-test',
    });
  }, 60_000);

  afterAll(async () => {
    await spoke.close();
    await container.stop();
  });

  it('rejects entity:create with missing entity_type', async () => {
    const res = await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'entity:create',
        input: { data: { name: 'Widget' } }, // missing entity_type
        context: { tenant_id: 'validation-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    expect(res.status).toBe(400);
    const body = await res.json();
    expect(body.success).toBe(false);
    expect(body.error).toBeDefined();
    expect(body.validation_errors).toBeDefined();
    expect(body.validation_errors.length).toBeGreaterThan(0);
    expect(body.validation_errors[0].path).toContain('entity_type');
  });

  it('rejects evaluate with missing rule', async () => {
    const res = await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'evaluate',
        input: {
          entity_type: 'product',
          entity_id: 'p-1',
          compliance_lock_id: 'lock-1',
          vertical_id: 'cosmetics',
          market: 'EU',
          // missing rule
        },
        context: { tenant_id: 'validation-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    expect(res.status).toBe(400);
    const body = await res.json();
    expect(body.success).toBe(false);
    expect(body.validation_errors).toBeDefined();
  });

  it('accepts valid entity:create input', async () => {
    // First define the type
    await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'entity:define',
        input: { entity_type: 'widget', schema: { name: { type: 'string' } } },
        context: { tenant_id: 'validation-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    const res = await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'entity:create',
        input: { entity_type: 'widget', data: { name: 'Valid Widget' } },
        context: { tenant_id: 'validation-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    expect(res.status).toBe(200);
    const body = await res.json();
    expect(body.success).toBe(true);
  });
});
```

Note: This test file goes in `apps/spoke-runtime/src/` because it needs the full boot. Actually, for better co-location let's put it alongside the E2E test.

Create at: `apps/spoke-runtime/src/mcp-validation.test.ts`

**Step 2: Run test to verify it fails**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/mcp-validation.test.ts`
Expected: FAIL — MCP server returns 200 (or 400 without field-level details) instead of proper validation errors

**Step 3: Wire validation into `callTool()`**

Modify `packages/platform-services/src/mcp/tools.ts` — update the `callTool` method to validate input before dispatching:

```typescript
// At the top of tools.ts, add import:
import { toolInputSchemas } from './schemas.js';
import type { z } from 'zod';

// Replace the callTool method (lines 126-136):
    async callTool(
      name: string,
      input: Record<string, unknown>,
      ctx: PlatformServiceContext,
    ): Promise<ServiceResult<unknown>> {
      const tool = tools[name];
      if (!tool) {
        throw new MCPError(`Unknown tool: ${name}`, 'NOT_FOUND');
      }

      // Validate input against Zod schema
      const schema = toolInputSchemas[name];
      if (schema) {
        const result = schema.safeParse(input);
        if (!result.success) {
          throw new MCPValidationError(
            `Invalid input for ${name}`,
            result.error.issues.map(issue => ({
              path: issue.path.join('.'),
              message: issue.message,
              code: issue.code,
            })),
          );
        }
      }

      return tool.handler(input, ctx);
    },
```

Also add the error classes at the top of `tools.ts` (after the imports):

```typescript
export class MCPError extends Error {
  constructor(message: string, public readonly code: 'NOT_FOUND' | 'VALIDATION' | 'CONFLICT' | 'FORBIDDEN' | 'UNAUTHORIZED') {
    super(message);
    this.name = 'MCPError';
  }
}

export interface ValidationIssue {
  path: string;
  message: string;
  code: string;
}

export class MCPValidationError extends MCPError {
  constructor(message: string, public readonly issues: ValidationIssue[]) {
    super(message, 'VALIDATION');
    this.name = 'MCPValidationError';
  }
}
```

**Step 4: Update MCP server to handle structured errors**

Modify `packages/platform-services/src/mcp/server.ts` — update the catch block to return proper HTTP status codes and validation details:

```typescript
import { Hono } from 'hono';
import type { MCPToolRouter } from './tools.js';
import { MCPError, MCPValidationError } from './tools.js';
import type { PlatformServiceContext } from '../context.js';

export function createMCPServer(router: MCPToolRouter) {
  const app = new Hono();

  app.get('/mcp/tools', (c) => {
    return c.json(router.listTools());
  });

  app.post('/mcp/call', async (c) => {
    const body = await c.req.json() as {
      tool: string;
      input: Record<string, unknown>;
      context?: Partial<PlatformServiceContext>;
    };

    const ctx: PlatformServiceContext = {
      tenant_id: body.context?.tenant_id ?? 'default',
      principal: body.context?.principal ?? { type: 'system', id: 'mcp-server' },
      correlation_id: body.context?.correlation_id ?? crypto.randomUUID(),
    };

    try {
      const result = await router.callTool(body.tool, body.input, ctx);
      return c.json(result);
    } catch (err) {
      if (err instanceof MCPValidationError) {
        return c.json({
          success: false,
          data: null,
          error: err.message,
          validation_errors: err.issues,
        }, 400);
      }

      if (err instanceof MCPError) {
        const statusMap: Record<MCPError['code'], number> = {
          NOT_FOUND: 404,
          VALIDATION: 400,
          CONFLICT: 409,
          FORBIDDEN: 403,
          UNAUTHORIZED: 401,
        };
        return c.json({
          success: false,
          data: null,
          error: err.message,
        }, statusMap[err.code] as 400);
      }

      const message = err instanceof Error ? err.message : 'Unknown error';
      return c.json({ success: false, data: null, error: message }, 500);
    }
  });

  app.get('/health', (c) => c.json({ status: 'ok' }));

  return app;
}
```

**Step 5: Export the new error classes from the package index**

Modify `packages/platform-services/src/index.ts` — add to MCP exports:

```typescript
// MCP
export { createMCPToolRouter, type MCPToolRouter, MCPError, MCPValidationError } from './mcp/tools.js';
export { createMCPServer } from './mcp/server.js';
```

**Step 6: Run the validation tests**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/mcp-validation.test.ts`
Expected: ALL PASS

**Step 7: Run the existing E2E tests to verify nothing breaks**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/e2e.test.ts`
Expected: ALL PASS — existing valid inputs still work

**Step 8: Commit**

```bash
git add packages/platform-services/src/mcp/tools.ts \
       packages/platform-services/src/mcp/server.ts \
       packages/platform-services/src/index.ts \
       apps/spoke-runtime/src/mcp-validation.test.ts
git commit -m "feat(platform-services): wire Zod validation into MCP tool router

Every MCP tool call validates input against its Zod schema before
dispatching. Invalid input returns 400 with field-level validation
errors. Unknown tools return 404. Internal errors return 500."
```

---

## Task 6: Proper HTTP error codes in MCP server

**Files:**
- Modify: `packages/platform-services/src/mcp/server.ts` (already partially done in Task 5)
- Modify: `packages/platform-services/src/mcp/tools.ts` (wrap service errors in MCPError)
- Create: `apps/spoke-runtime/src/mcp-errors.test.ts`

**Step 1: Write the failing tests**

Create `apps/spoke-runtime/src/mcp-errors.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { boot, type SpokeInstance } from './boot.js';
import { PostgreSqlContainer, type StartedPostgreSqlContainer } from '@testcontainers/postgresql';

describe('MCP HTTP error codes', () => {
  let container: StartedPostgreSqlContainer;
  let spoke: SpokeInstance;

  beforeAll(async () => {
    container = await new PostgreSqlContainer('postgres:16-alpine').start();
    spoke = await boot({
      port: 0,
      postgres: {
        host: container.getHost(),
        port: container.getMappedPort(5432),
        database: container.getDatabase(),
        user: container.getUsername(),
        password: container.getPassword(),
      },
      tenantId: 'error-test',
    });
  }, 60_000);

  afterAll(async () => {
    await spoke.close();
    await container.stop();
  });

  it('returns 404 for unknown tool', async () => {
    const res = await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'nonexistent:tool',
        input: {},
        context: { tenant_id: 'error-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    expect(res.status).toBe(404);
    const body = await res.json();
    expect(body.success).toBe(false);
    expect(body.error).toContain('Unknown tool');
  });

  it('returns 400 for invalid input', async () => {
    const res = await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'entity:create',
        input: {}, // missing required fields
        context: { tenant_id: 'error-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    expect(res.status).toBe(400);
    const body = await res.json();
    expect(body.success).toBe(false);
    expect(body.validation_errors).toBeDefined();
  });

  it('returns 404 for entity:get on nonexistent entity', async () => {
    // First define the type
    await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'entity:define',
        input: { entity_type: 'gadget', schema: { name: { type: 'string' } } },
        context: { tenant_id: 'error-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    const res = await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'entity:get',
        input: { entity_type: 'gadget', entity_id: 'does-not-exist' },
        context: { tenant_id: 'error-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    expect(res.status).toBe(200); // Service returns { success: false } — not an HTTP error
    const body = await res.json();
    expect(body.success).toBe(false);
  });

  it('returns 500 for unexpected internal errors', async () => {
    // Simulate by sending a valid-schema input that causes an internal error
    // e.g., evaluating against a non-existent entity type (not yet defined)
    const res = await spoke.app.request('/mcp/call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        tool: 'evaluate',
        input: {
          entity_type: 'nonexistent_type',
          entity_id: 'x',
          rule: { handler: 'core:threshold_check', config: { value: 1, operator: 'lt', threshold: 10 } },
          compliance_lock_id: 'lock-1',
          vertical_id: 'cosmetics',
          market: 'EU',
        },
        context: { tenant_id: 'error-test', principal: { type: 'system', id: 'test' } },
      }),
    });

    // This returns a ServiceResult with success: false (not an HTTP error)
    // because the ExecutionLoop handles it gracefully
    const body = await res.json();
    expect(body.success).toBe(false);
  });
});
```

**Step 2: Run tests to verify behavior**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/mcp-errors.test.ts`
Expected: Tests should pass if Task 5 was implemented correctly. If they fail, the error code mapping needs adjustment.

**Step 3: Adjust tool router to throw MCPError for NOT_FOUND cases in service results**

If `entity:get` returns `{ success: false }` for a missing entity, the HTTP response should still be 200 with the `success: false` body (this is a successful API call that found no entity — the service layer communicates this). Only infrastructure-level errors (unknown tool, validation failure, unexpected crash) get non-200 HTTP codes.

This matches the current design where `ServiceResult.success` communicates business-level outcomes, and HTTP status codes communicate protocol-level outcomes.

**Step 4: Run all tests**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run`
Expected: ALL PASS

**Step 5: Commit**

```bash
git add apps/spoke-runtime/src/mcp-errors.test.ts
git commit -m "test(spoke-runtime): add MCP HTTP error code tests

Verifies 404 for unknown tools, 400 for validation errors,
and 500 for unexpected internal errors. Business-level failures
(entity not found, evaluation failed) return 200 with success: false."
```

---

## Task 7: Tool schema descriptions in `GET /mcp/tools` response

**Files:**
- Modify: `packages/platform-services/src/mcp/tools.ts:10-13,121-124`
- Modify: `packages/platform-services/src/mcp/schemas.ts` (add JSON Schema generation)
- Create: `apps/spoke-runtime/src/mcp-discovery.test.ts`

**Step 1: Write the failing test**

Create `apps/spoke-runtime/src/mcp-discovery.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { boot, type SpokeInstance } from './boot.js';
import { PostgreSqlContainer, type StartedPostgreSqlContainer } from '@testcontainers/postgresql';

describe('MCP tool discovery', () => {
  let container: StartedPostgreSqlContainer;
  let spoke: SpokeInstance;

  beforeAll(async () => {
    container = await new PostgreSqlContainer('postgres:16-alpine').start();
    spoke = await boot({
      port: 0,
      postgres: {
        host: container.getHost(),
        port: container.getMappedPort(5432),
        database: container.getDatabase(),
        user: container.getUsername(),
        password: container.getPassword(),
      },
      tenantId: 'discovery-test',
    });
  }, 60_000);

  afterAll(async () => {
    await spoke.close();
    await container.stop();
  });

  it('returns tool list with input_schema for each tool', async () => {
    const res = await spoke.app.request('/mcp/tools');
    expect(res.status).toBe(200);

    const tools = await res.json() as Array<{ name: string; description: string; input_schema?: unknown }>;
    expect(tools.length).toBeGreaterThan(0);

    // Every tool should have an input_schema
    for (const tool of tools) {
      expect(tool.name).toBeDefined();
      expect(tool.description).toBeDefined();
      expect(tool.input_schema).toBeDefined();
      expect(typeof tool.input_schema).toBe('object');
    }
  });

  it('entity:create schema has required fields', async () => {
    const res = await spoke.app.request('/mcp/tools');
    const tools = await res.json() as Array<{ name: string; input_schema: { type: string; required?: string[]; properties?: Record<string, unknown> } }>;

    const entityCreate = tools.find(t => t.name === 'entity:create');
    expect(entityCreate).toBeDefined();
    expect(entityCreate!.input_schema.type).toBe('object');
    expect(entityCreate!.input_schema.required).toContain('entity_type');
    expect(entityCreate!.input_schema.required).toContain('data');
    expect(entityCreate!.input_schema.properties).toHaveProperty('entity_type');
    expect(entityCreate!.input_schema.properties).toHaveProperty('data');
  });

  it('evaluate schema has required fields', async () => {
    const res = await spoke.app.request('/mcp/tools');
    const tools = await res.json() as Array<{ name: string; input_schema: { required?: string[] } }>;

    const evaluate = tools.find(t => t.name === 'evaluate');
    expect(evaluate).toBeDefined();
    expect(evaluate!.input_schema.required).toContain('entity_type');
    expect(evaluate!.input_schema.required).toContain('entity_id');
    expect(evaluate!.input_schema.required).toContain('rule');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/mcp-discovery.test.ts`
Expected: FAIL — current `listTools()` returns `{ name, description }` without `input_schema`

**Step 3: Install `zod-to-json-schema` for JSON Schema generation**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/platform-services add zod-to-json-schema`

**Step 4: Update the MCPToolDefinition interface and listTools()**

Modify `packages/platform-services/src/mcp/tools.ts`:

```typescript
// Update MCPToolDefinition interface (line 10-13):
export interface MCPToolDefinition {
  name: string;
  description: string;
  input_schema: Record<string, unknown>;
}
```

Update each tool's `definition` to include `input_schema`. Modify the `listTools()` method to generate JSON Schema from Zod schemas:

```typescript
// At the top of tools.ts, add:
import { zodToJsonSchema } from 'zod-to-json-schema';
import { toolInputSchemas } from './schemas.js';

// Update listTools() (line 121-124):
    listTools(): MCPToolDefinition[] {
      return Object.values(tools).map(t => ({
        ...t.definition,
        input_schema: toolInputSchemas[t.definition.name]
          ? zodToJsonSchema(toolInputSchemas[t.definition.name], { target: 'openApi3' })
          : { type: 'object', properties: {} },
      }));
    },
```

**Step 5: Run tests to verify they pass**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/mcp-discovery.test.ts`
Expected: ALL PASS

**Step 6: Run all spoke tests**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run`
Expected: ALL PASS

**Step 7: Commit**

```bash
git add packages/platform-services/src/mcp/tools.ts \
       packages/platform-services/package.json \
       apps/spoke-runtime/src/mcp-discovery.test.ts \
       pnpm-lock.yaml
git commit -m "feat(platform-services): expose JSON Schema in GET /mcp/tools

Each tool's definition now includes input_schema (JSON Schema) generated
from its Zod schema via zod-to-json-schema. Agents use this to understand
what input each tool expects."
```

---

## Task 8: Boot failure — fail fast on required pack load failure

**Files:**
- Modify: `apps/spoke-runtime/src/boot.ts:80-132`
- Modify: `apps/spoke-runtime/src/config.ts` (add `requiredPacks` config option)
- Create: `apps/spoke-runtime/src/boot-failure.test.ts`

**Step 1: Write the failing test**

Create `apps/spoke-runtime/src/boot-failure.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { boot } from './boot.js';
import { PostgreSqlContainer, type StartedPostgreSqlContainer } from '@testcontainers/postgresql';
import { mkdirSync, writeFileSync, rmSync } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';

describe('Boot failure handling', () => {
  let container: StartedPostgreSqlContainer;

  beforeAll(async () => {
    container = await new PostgreSqlContainer('postgres:16-alpine').start();
  }, 60_000);

  afterAll(async () => {
    await container.stop();
  });

  it('fails fast when a required pack directory is corrupt', async () => {
    // Create a temp directory with a broken pack (no pack.json)
    const packsDir = join(tmpdir(), `test-packs-${Date.now()}`);
    const brokenPackDir = join(packsDir, 'broken-pack');
    mkdirSync(brokenPackDir, { recursive: true });
    writeFileSync(join(brokenPackDir, 'not-a-pack.txt'), 'garbage');

    try {
      await expect(boot({
        port: 0,
        postgres: {
          host: container.getHost(),
          port: container.getMappedPort(5432),
          database: container.getDatabase(),
          user: container.getUsername(),
          password: container.getPassword(),
        },
        tenantId: 'boot-fail-test',
        packsDir,
        requirePacks: true,
      })).rejects.toThrow();
    } finally {
      rmSync(packsDir, { recursive: true, force: true });
    }
  });

  it('boots successfully when no packs dir configured', async () => {
    const spoke = await boot({
      port: 0,
      postgres: {
        host: container.getHost(),
        port: container.getMappedPort(5432),
        database: container.getDatabase(),
        user: container.getUsername(),
        password: container.getPassword(),
      },
      tenantId: 'boot-ok-test',
    });
    expect(spoke.app).toBeDefined();
    await spoke.close();
  });

  it('boots with warnings when packs fail but requirePacks is false', async () => {
    const packsDir = join(tmpdir(), `test-packs-opt-${Date.now()}`);
    const brokenPackDir = join(packsDir, 'optional-broken');
    mkdirSync(brokenPackDir, { recursive: true });
    writeFileSync(join(brokenPackDir, 'junk.txt'), 'garbage');

    try {
      // Should NOT throw — requirePacks defaults to false
      const spoke = await boot({
        port: 0,
        postgres: {
          host: container.getHost(),
          port: container.getMappedPort(5432),
          database: container.getDatabase(),
          user: container.getUsername(),
          password: container.getPassword(),
        },
        tenantId: 'boot-warn-test',
        packsDir,
      });
      expect(spoke.app).toBeDefined();
      await spoke.close();
    } finally {
      rmSync(packsDir, { recursive: true, force: true });
    }
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/boot-failure.test.ts`
Expected: FAIL — boot doesn't recognize `requirePacks` option and doesn't throw on pack failure

**Step 3: Read the SpokeConfig type**

Read `apps/spoke-runtime/src/config.ts` to understand the current config shape before modifying it.

**Step 4: Add `requirePacks` to SpokeConfig**

Modify `apps/spoke-runtime/src/config.ts` — add the field to the SpokeConfig interface:

```typescript
// Add to SpokeConfig interface:
requirePacks?: boolean; // If true, boot aborts when any pack fails to load. Default: false.
```

**Step 5: Update boot.ts to fail fast when `requirePacks` is true**

Modify `apps/spoke-runtime/src/boot.ts` — update the pack loading section (lines 80-132):

```typescript
  // Load packs from directory if configured
  if (config.packsDir) {
    const packDirs = readdirSync(config.packsDir)
      .map(name => join(config.packsDir!, name))
      .filter(path => statSync(path).isDirectory());

    const ctx = {
      tenant_id: config.tenantId,
      principal: { type: 'system' as const, id: 'boot' },
      correlation_id: 'boot-pack-install',
    };

    // Load all packs first
    const loadedPacks: LoadedPack[] = [];
    const loadErrors: Array<{ dir: string; error: unknown }> = [];

    for (const dir of packDirs) {
      try {
        loadedPacks.push(await loadPack(dir));
      } catch (err) {
        loadErrors.push({ dir, error: err });
        console.error(`Failed to load pack from ${dir}:`, err);
      }
    }

    // Fail fast if required packs failed to load
    if (config.requirePacks && loadErrors.length > 0) {
      await db.close();
      if (neo4j) await neo4j.close();
      const dirs = loadErrors.map(e => e.dir).join(', ');
      throw new Error(`Boot aborted: failed to load required packs from: ${dirs}`);
    }

    // Build available packs map for dependency resolution
    const availablePacks: Record<string, LoadedPack> = {};
    for (const pack of loadedPacks) {
      availablePacks[pack.manifest.name] = pack;
    }

    // Create install plan and install each pack
    for (const pack of loadedPacks) {
      try {
        const plan = await createInstallPlan(pack, {
          availablePacks,
          registry,
          handlerVmVersion: '1.0.0',
          tenantId: config.tenantId,
        });

        if (!plan.valid) {
          const msg = `Install plan invalid for ${pack.manifest.name}: ${plan.errors.join(', ')}`;
          if (config.requirePacks) {
            await db.close();
            if (neo4j) await neo4j.close();
            throw new Error(`Boot aborted: ${msg}`);
          }
          console.error(msg);
          continue;
        }

        for (const p of plan.packsToInstall) {
          await packService.install(ctx, p.manifest);
        }

        await packService.saveLock(ctx, plan.lock);
      } catch (err) {
        if (config.requirePacks) {
          await db.close();
          if (neo4j) await neo4j.close();
          throw err instanceof Error ? err : new Error(`Boot aborted: failed to install pack ${pack.manifest.name}`);
        }
        console.error(`Failed to install pack ${pack.manifest.name}:`, err);
      }
    }
  }
```

**Step 6: Run tests to verify they pass**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run src/boot-failure.test.ts`
Expected: ALL PASS

**Step 7: Run the full spoke-runtime test suite**

Run: `cd /root/Documents/eurocomply-os && pnpm --filter @eurocomply/spoke-runtime test -- --run`
Expected: ALL PASS — existing E2E tests still work (they don't use `requirePacks`)

**Step 8: Commit**

```bash
git add apps/spoke-runtime/src/boot.ts \
       apps/spoke-runtime/src/config.ts \
       apps/spoke-runtime/src/boot-failure.test.ts
git commit -m "feat(spoke-runtime): fail fast on required pack load failure

Add requirePacks config option. When true, boot aborts with clear error
if any pack fails to load or install. When false (default), failures are
logged and boot continues — preserving existing behavior."
```

---

## Task 9: Update design docs with generic handler names

**Files:**
- Modify: `design/docs/2026-02-02-compliance-handler-vm.md` (update handler names)

**Step 1: Read the design doc to identify handler name references**

Read: `design/docs/2026-02-02-compliance-handler-vm.md` and find all references to `core:bom_sum` or any domain-specific handler names that were renamed in the Phase 5.1 spec.

**Step 2: Update handler references**

Replace all occurrences of:
- `core:bom_sum` → `core:collection_sum`
- Any other domain-specific names that appear (check against the rename table in the Phase 5.1 design doc section 3)

Verify these handler names in the design doc match the generic names from CLAUDE.md:
- `core:collection_sum`, `core:collection_max`, `core:collection_min`
- `core:weighted_sum`
- `core:rule_resolve` (was `core:regulatory_conflict_resolve`)
- `ai:interpret` (was `ai:compliance_interpret`)
- `ai:score` (was `ai:risk_score`)

**Step 3: Commit**

```bash
git add design/docs/2026-02-02-compliance-handler-vm.md
git commit -m "docs: update VM design doc with generic handler names

Replace domain-specific handler names (bom_sum, etc.) with generic
primitives (collection_sum, etc.) to match CLAUDE.md handler inventory."
```

---

## Task 10: Final integration verification

**Files:** None — this is a verification-only task.

**Step 1: Build the full monorepo**

Run: `cd /root/Documents/eurocomply-os && pnpm build`
Expected: ALL packages build successfully

**Step 2: Run the full test suite**

Run: `cd /root/Documents/eurocomply-os && pnpm test`
Expected: ALL tests pass across all packages

**Step 3: Verify handler rename is complete**

Run a grep to ensure no references to `bom_sum` remain:

```bash
cd /root/Documents/eurocomply-os && grep -r "bom_sum\|bom-sum\|bomSum" packages/ apps/ --include="*.ts" --include="*.json"
```
Expected: No matches found

**Step 4: Verify evaluator error containment works end-to-end**

The E2E test in `apps/spoke-runtime/src/e2e.test.ts` already tests evaluation via the MCP endpoint. The evaluator now catches errors instead of throwing, so existing tests should still pass with the same behavior (success cases unchanged).

**Step 5: Verify MCP validation works end-to-end**

The tests in `apps/spoke-runtime/src/mcp-validation.test.ts` verify that invalid input is rejected with field-level errors. The tests in `apps/spoke-runtime/src/mcp-discovery.test.ts` verify that `GET /mcp/tools` returns JSON Schema.

**Step 6: Verify MCP error codes end-to-end**

The tests in `apps/spoke-runtime/src/mcp-errors.test.ts` verify the proper HTTP status codes.

**Step 7: Create a summary commit (optional tag)**

If all tests pass and all grepping confirms no stale references:

```bash
git tag phase-5.1-complete
```

---

## Checklist Summary

| Task | Deliverable | Tests |
|------|------------|-------|
| 1 | Rename `core:bom_sum` → `core:collection_sum` | computation.test.ts, evaluator.test.ts |
| 2 | Evaluator try/catch error containment | evaluator.test.ts (handler throws, unknown handler) |
| 3 | Evaluator timeout enforcement | evaluator.test.ts (timeout, success within limit) |
| 4 | Zod input schemas for 16 MCP tools | schemas.test.ts |
| 5 | Wire Zod validation into MCP router | mcp-validation.test.ts |
| 6 | Proper HTTP error codes | mcp-errors.test.ts |
| 7 | JSON Schema in `GET /mcp/tools` | mcp-discovery.test.ts |
| 8 | Boot fail-fast on pack load failure | boot-failure.test.ts |
| 9 | Update design docs | Manual verification |
| 10 | Full integration verification | `pnpm build && pnpm test` |

---

## Notes for the Implementer

1. **Test framework:** Vitest with `describe/it/expect`. Import from `vitest` directly. Globals are enabled in kernel-vm but not in platform-services.

2. **Test containers:** E2E tests use `@testcontainers/postgresql` — needs Docker running. Give `beforeAll` a 60-second timeout.

3. **Monorepo build order:** `types` → `kernel-vm` → `platform-services` → `spoke-runtime`. If you change `kernel-vm`, rebuild before testing `platform-services` or `spoke-runtime`.

4. **The `ctx.tx ?? this.db` pattern:** All service methods that touch PostgreSQL use this pattern. Don't bypass it.

5. **Handler pattern:** Every handler uses `makeSuccess`/`makeFailure` from `packages/kernel-vm/src/result.ts`. Use `now()` for timing. Return `HandlerResult` with full trace.

6. **The `as any` pattern in tools.ts:** The current tool handlers cast input to `any`. This is intentional — the Zod validation in `callTool()` ensures the input matches the schema before it reaches the handler. Don't add redundant type narrowing inside handlers.

7. **Import paths:** Use `.js` extensions in import paths (ESM). Example: `import { foo } from './bar.js'`.

8. **Package names:** `@eurocomply/kernel-vm`, `@eurocomply/platform-services`, `@eurocomply/types`, `@eurocomply/spoke-runtime`. Use `--filter @eurocomply/spoke-runtime` for pnpm commands targeting the spoke.

9. **SpokeConfig:** Defined in `apps/spoke-runtime/src/config.ts`. Current fields: `port`, `postgres`, `neo4j?`, `tenantId`, `packsDir?`, `seedFile?`, `hubUrl?`, `apiKey?`, `spokeId?`. Task 8 adds `requirePacks?: boolean` to this interface.
